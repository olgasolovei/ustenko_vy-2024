# Опис шаблонів проєктування

## 1. Ланцюжок обов'язків
**Шаблон проєктування «Ланцюжок обов'язків»** дозволяє передавати запити через ланцюжок обробників, де кожен обробник або обробляє запит, або передає його наступному в ланцюжку. Кожен обробник реалізує загальний інтерфейс із методом для обробки запитів і посиланням на наступного обробника. Це дає змогу динамічно змінювати ланцюжок обробників та знижує залежність між компонентами. Клієнт надсилає запит на перший обробник ланцюжка, і той або обробляє його, або передає наступному до знаходження відповідного обробника.

## 2. Команда
**Шаблон проєктування «Команда»** дозволяє інкапсулювати запит як об'єкт, що містить всі необхідні дані для виконання дії. Це дозволяє передавати, зберігати та виконувати запити, а також надає можливість скасування або повторного виконання операцій. Шаблон включає інтерфейс команди з методом `execute()`, який реалізує конкретні операції, а також об'єкти, що виконують ці команди. Це дає змогу створювати складні операції через комбінування простих команд, зберігати історію дій і управляти виконанням через виклики команд.

## 3. Посередник
**Шаблон проєктування «Посередник»** визначає об'єкт, який управляє взаємодією між іншими об'єктами, знижуючи їх залежність. Замість того, щоб об'єкти безпосередньо взаємодіяли один з одним, вони передають свої запити через посередника. Це дозволяє спростити взаємодію між компонентами, зменшуючи складність системи і кількість зв'язків між об'єктами. Посередник має інтерфейс для обробки запитів і делегує їх відповідним об'єктам. В результаті, компоненти не знають один про одного, що забезпечує більшу гнучкість і можливість змінювати взаємодії без зміни самих об'єктів.

## 4. Знімок
**Шаблон проєктування «Знімок» (Memento)** дозволяє зберігати й відновлювати попередній стан об'єкта без порушення інкапсуляції. Він складається з трьох основних компонентів:
- **Об'єкт, що зберігає стан (Originator)** — об'єкт, стан якого потрібно зберегти. Він створює знімок свого стану та може відновити цей стан пізніше.
- **Знімок (Memento)** — об'єкт, який містить збережений стан об'єкта. Він зберігає дані таким чином, щоб об'єкт, що створив знімок, не міг їх змінити.
- **Менеджер знімків (Caretaker)** — об'єкт, який відповідальний за зберігання та відновлення знімків, але не змінює вміст знімків. Він використовує знімки для відновлення стану об'єкта.

Шаблон дозволяє легко зберігати історію змін об'єкта і відновлювати його попередні стани без прямого доступу до його внутрішніх даних.

## 5. Спостерігач
**Шаблон проєктування «Спостерігач» (Observer)** визначає відношення один до багатьох між об'єктами, де один об'єкт (спостерігач) спостерігає за змінами в іншому об'єкті (суб'єкті) і автоматично отримує оновлення, коли відбуваються зміни.

Основні компоненти:
- **Суб'єкт (Subject)** — об'єкт, стан якого відстежується. Він підтримує список спостерігачів та повідомляє їх про зміни.
- **Спостерігач (Observer)** — об'єкт, який отримує оновлення від суб'єкта. Спостерігач реалізує інтерфейс, що дозволяє йому отримувати повідомлення про зміни.
- **Конкретний суб'єкт (Concrete Subject)** — клас, який реалізує інтерфейс суб'єкта і зберігає власний стан. Він інформує спостерігачів про зміни.
- **Конкретний спостерігач (Concrete Observer)** — клас, що реалізує інтерфейс спостерігача і відповідає на повідомлення про зміни у суб'єкті.

Цей шаблон дозволяє створювати гнучкі системи, де об'єкти можуть відстежувати інші без необхідності прямого зв'язку між ними.

## 6. Стан
**Шаблон проєктування «Стан» (State)** дозволяє змінювати поведінку об'єкта залежно від його внутрішнього стану, при цьому приховуючи складність цих змін від клієнта. Об'єкт може змінювати свій стан динамічно, і кожен стан реалізує свою поведінку, замінюючи необхідність великої кількості умовних операторів.

Основні компоненти:
- **Контекст (Context)** — об'єкт, чия поведінка змінюється в залежності від стану. Контекст зберігає посилання на поточний стан і делегує йому виконання операцій.
- **Стан (State)** — інтерфейс, який визначає операції, що можуть бути виконані в кожному стані. У контексті, це методи, які викликаються, коли об'єкт знаходиться в конкретному стані.
- **Конкретний стан (Concrete State)** — реалізації інтерфейсу стану, які містять конкретну логіку для кожного стану об'єкта. Кожен стан відповідає за виконання специфічних операцій у відповідному контексті.

Шаблон дозволяє об'єкту змінювати свою поведінку без необхідності змінювати його код, просто змінюючи внутрішній стан, що робить програму більш гнучкою та зрозумілою.

## 7. Стратегія
**Шаблон проєктування «Стратегія» (Strategy)** визначає сімейство алгоритмів, інкапсулює кожен з них і робить їх взаємозамінними. Це дозволяє змінювати поведінку об'єкта під час виконання, не змінюючи його код. Шаблон дозволяє вибирати конкретну стратегію для виконання операції в залежності від контексту.

Основні компоненти:
- **Контекст (Context)** — об'єкт, що використовує стратегію. Він зберігає посилання на конкретну стратегію і делегує виконання операцій цій стратегії.
- **Стратегія (Strategy)** — інтерфейс, який визначає загальний алгоритм, що може бути реалізований різними конкретними стратегіями.
- **Конкретна стратегія (Concrete Strategy)** — реалізації інтерфейсу стратегії, які виконують конкретні алгоритми чи операції.

Шаблон дозволяє вибирати і змінювати алгоритми або стратегії без зміни коду клієнта, що робить систему більш гнучкою і масштабованою.

## 8. Шаблонний метод
**Шаблон проєктування «Шаблонний метод» (Template Method)** визначає структуру алгоритму, дозволяючи підкласам змінювати частини цього алгоритму без зміни його загальної структури. Це дозволяє забезпечити загальну послідовність виконання кроків алгоритму, делегуючи конкретні етапи підкласам.

Основні компоненти:
- **Абстрактний клас (Abstract Class)** — містить шаблонний метод, що реалізує загальну структуру алгоритму. Частини алгоритму, які можуть змінюватися, визначені як абстрактні методи або методи з частковою реалізацією.
- **Шаблонний метод (Template Method)** — метод, що визначає порядок виконання алгоритму, включаючи виклики конкретних кроків, які можуть бути реалізовані в підкласах.
- **Конкретні підкласи (Concrete Subclasses)** — нащадки абстрактного класу, які реалізують конкретні етапи алгоритму, визначені абстрактними методами.

Шаблон дозволяє забезпечити універсальну структуру алгоритму, з можливістю змінювати тільки конкретні його частини.

## 9. Відвідувач
**Шаблон проєктування «Відвідувач» (Visitor)** дозволяє додавати нові операції до об'єктів, не змінюючи їх структури. Це досягається через введення об'єкта-відвідувача, який виконує операції над елементами без безпосереднього доступу до їх внутрішніх даних.

Основні компоненти:
- **Елемент (Element)** — інтерфейс або абстрактний клас, який визначає метод для прийому відвідувача.
- **Конкретний елемент (Concrete Element)** — клас, який реалізує метод для прийому відвідувача.
- **Відвідувач (Visitor)** — інтерфейс, що визначає методи для обробки різних типів елементів.
- **Конкретний відвідувач (Concrete Visitor)** — реалізація відвідувача, яка визначає операції для кожного елемента.

Шаблон дозволяє змінювати операції для елементів без необхідності змінювати самі елементи, що робить систему більш гнучкою.
